apply plugin : 'eclipse'
apply plugin : 'java'
import com.manning.gia.ProjectVersion
import com.manning.gia.ReleaseVersionTask
import com.manning.gia.ReleaseVersionListener
ext.versionFile = file('version.properties')
ext.cargoGroup = 'org.codehaus.cargo'
ext.cargoVersion = '1.3.1'
configurations { 
	cargo {
		description = 'Classpath for cargo ANT tasks'
		visible = false
	}
}
task deployToLocalTomcat << {
	FileTree cargoDeps = configurations.cargo.asFileTree
	ant.taskdef(resource: 'cargo.tasks', classpath: cargoDeps.asPath)
	ant.cargo(containerID: 'tomcat7x', action: 'run', output: "$buildDir/output.log"){
		configuration {
			deployable(type: 'war', file: 'ToDoApp.war')
		}
		zipUrlInstaller(installUrl : 'http://archive.apache.org/dist/tomcat/tomcat-7/v7.0.32/bin/apache-tomcat-7.0.32.zip')
	}
}
task copyDependenciesToLocalDir(type: Copy) {
	from configurations.cargo.asFileTree
	into "${System.properties['user.home']}/libs/cargo"
}
repositories {
	mavenCentral()
}
	
dependencies {
	cargo group: cargoGroup, name: 'cargo-core-uberjar',version: cargoVersion
	cargo "$cargoGroup:cargo-ant:$cargoVersion"
}

task loadVersion {
	project.version=readVersion()
}
ProjectVersion readVersion() {
	logger.quiet('Reading version file')
	
	if(!versionFile.exists())
		throw new GradleException("Required version file does not exists : $versionFile.canonicalPath")
	
	Properties versionProps = new Properties();
	
	versionFile.withInputStream { stream ->
		versionProps.load(stream)
	}
	new ProjectVersion(versionProps.major.toInteger(),versionProps.minor.toInteger(),versionProps.release.toBoolean())
}


/*task makeReleaseVersion(type: ReleaseVersionTask) {
	release=version.release
	destFile= versionFile
}
*/


task createDistribution(type: Zip){
	from jar.outputs.files
	
	from(sourceSets*.allSource){
		into 'src'
	}
	
	from(rootDir){
		include versionFile.name
	}
}
task backupReleaseDistribution(type: Copy){
	from createDistribution.outputs.files
	into "$buildDir/backup"
}

task release(dependsOn : backupReleaseDistribution){
	logger.quiet "Releasing Distribuion with version = $project.version"
}	

tasks.addRule("Pattern : increment<classifier>Version - increments the project version classifier") { String taskName ->
	if(taskName.startsWith('increment') && taskName.endsWith('Version')){
		task (taskName) << {
			String classifier = (taskName - 'increment' - 'Version').toLowerCase()
			String currentVersion = project.version.toString();
			String newVersion
			switch(classifier){
				case 'major' :
					++version.major
					break
				case 'minor' :
					++version.minor
					break
				default :
					throw new GradleException("Invalid version classifier : $classifier. Allowed types : ['Major' ,'Minor']")
			}
			newVersion=version.toString();
			ant.propertyfile(file: versionFile){
				entry(key : classifier, type : 'int', operation: '+', value: 1)
			}
		}
	}
}

/*
gradle.taskGraph.whenReady{ TaskExecutionGraph taskGraph ->
	if(taskGraph.hasTask(release)){
		if(!version.release){
			version.release=true
			ant.propertyfile(file: versionFile){
				entry(key: 'release', type: 'string', operation: '=', value: 'true')
			}
		}
	}
}
*/
def releaseVersionListener = new ReleaseVersionListener();
gradle.taskGraph.addTaskExecutionGraphListener(releaseVersionListener);